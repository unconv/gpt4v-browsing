{
    "summary": "The browser extension, using Puppeteer, OpenAI, and user input, highlights visible links on webpages, tracks conversations in the 'messages' array, utilizes Google search engine for information, checks for link clicks and page events, handles timeouts, captures screenshots, and records user input.",
    "details": [
        {
            "comment": "This code imports necessary libraries, sets up the Stealth plugin for Puppeteer, creates an instance of OpenAI, defines a function to convert images to base64, and initiates a readline interface for user input.",
            "location": "\"/media/root/Toshiba XG3/works/gpt4v-browsing/docs/src/vision_crawl.js\":0-38",
            "content": "import puppeteer from 'puppeteer-extra';\nimport StealthPlugin from 'puppeteer-extra-plugin-stealth';\nimport OpenAI from 'openai';\nimport readline from 'readline';\nimport fs from 'fs';\npuppeteer.use(StealthPlugin());\nconst openai = new OpenAI();\nconst timeout = 8000;\nasync function image_to_base64(image_file) {\n    return await new Promise((resolve, reject) => {\n        fs.readFile(image_file, (err, data) => {\n            if (err) {\n                console.error('Error reading the file:', err);\n                reject();\n                return;\n            }\n            const base64Data = data.toString('base64');\n            const dataURI = `data:image/jpeg;base64,${base64Data}`;\n            resolve(dataURI);\n        });\n    });\n}\nasync function input( text ) {\n    let the_prompt;\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout\n    });\n    await (async () => {\n        return new Promise( resolve => {\n            rl.question( text, (prompt) => {\n                the_prompt = prompt;"
        },
        {
            "comment": "The code is a browser extension or script that highlights links on a webpage. It first closes the Readline interface and resolves any pending operations. Then, it defines a sleep function for waiting during asynchronous operations. The main function is highlight_links which removes existing link markers from the page's HTML elements and finds all clickable elements on the page. Finally, it iterates through these elements, evaluating a function to determine if they are visible and possibly applying some visual effects like highlighting them.",
            "location": "\"/media/root/Toshiba XG3/works/gpt4v-browsing/docs/src/vision_crawl.js\":39-76",
            "content": "                rl.close();\n                resolve();\n            } );\n        } );\n    })();\n    return the_prompt;\n}\nasync function sleep( milliseconds ) {\n    return await new Promise((r, _) => {\n        setTimeout( () => {\n            r();\n        }, milliseconds );\n    });\n}\nasync function highlight_links( page ) {\n    await page.evaluate(() => {\n        document.querySelectorAll('[gpt-link-text]').forEach(e => {\n            e.removeAttribute(\"gpt-link-text\");\n        });\n    });\n    const elements = await page.$$(\n        \"a, button, input, textarea, [role=button], [role=treeitem]\"\n    );\n    elements.forEach( async e => {\n        await page.evaluate(e => {\n            function isElementVisible(el) {\n                if (!el) return false; // Element does not exist\n                function isStyleVisible(el) {\n                    const style = window.getComputedStyle(el);\n                    return style.width !== '0' &&\n                           style.height !== '0' &&\n                           style.opacity !== '0' &&"
        },
        {
            "comment": "Checks if the element is visible both style-wise and within viewport",
            "location": "\"/media/root/Toshiba XG3/works/gpt4v-browsing/docs/src/vision_crawl.js\":77-102",
            "content": "                           style.display !== 'none' &&\n                           style.visibility !== 'hidden';\n                }\n                function isElementInViewport(el) {\n                    const rect = el.getBoundingClientRect();\n                    return (\n                    rect.top >= 0 &&\n                    rect.left >= 0 &&\n                    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n                    rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n                    );\n                }\n                // Check if the element is visible style-wise\n                if (!isStyleVisible(el)) {\n                    return false;\n                }\n                // Traverse up the DOM and check if any ancestor element is hidden\n                let parent = el;\n                while (parent) {\n                    if (!isStyleVisible(parent)) {\n                    return false;\n                    }\n                    parent = parent.parentElement;"
        },
        {
            "comment": "Code snippet is initializing a browsing process using Puppeteer. It sets up event listeners for elements and waits for specific events to occur before taking action on them, such as extracting link text.",
            "location": "\"/media/root/Toshiba XG3/works/gpt4v-browsing/docs/src/vision_crawl.js\":103-137",
            "content": "                }\n                // Finally, check if the element is within the viewport\n                return isElementInViewport(el);\n            }\n            e.style.border = \"1px solid red\";\n            const position = e.getBoundingClientRect();\n            if( position.width > 5 && position.height > 5 && isElementVisible(e) ) {\n                const link_text = e.textContent.replace(/[^a-zA-Z0-9 ]/g, '');\n                e.setAttribute( \"gpt-link-text\", link_text );\n            }\n        }, e);\n    } );\n}\nasync function waitForEvent(page, event) {\n    return page.evaluate(event => {\n        return new Promise((r, _) => {\n            document.addEventListener(event, function(e) {\n                r();\n            });\n        });\n    }, event)\n}\n(async () => {\n    console.log( \"###########################################\" );\n    console.log( \"# GPT4V-Browsing by Unconventional Coding #\" );\n    console.log( \"###########################################\\n\" );\n    const browser = await puppeteer.launch( {\n        headless: \"new\","
        },
        {
            "comment": "This code sets up a browser instance with a specific viewport size and scale factor, then defines an initial message for the AI system that explains its role as a website crawler and provides instructions on how to interact with web pages. It starts by going to a given URL that might contain the answer to a question.",
            "location": "\"/media/root/Toshiba XG3/works/gpt4v-browsing/docs/src/vision_crawl.js\":138-161",
            "content": "    } );\n    const page = await browser.newPage();\n    await page.setViewport( {\n        width: 1200,\n        height: 1200,\n        deviceScaleFactor: 1.75,\n    } );\n    const messages = [\n        {\n            \"role\": \"system\",\n            \"content\": `You are a website crawler. You will be given instructions on what to do by browsing. You are connected to a web browser and you will be given the screenshot of the website you are on. The links on the website will be highlighted in red in the screenshot. Always read what is in the screenshot. Don't guess link names.\nYou can go to a specific URL by answering with the following JSON format:\n{\"url\": \"url goes here\"}\nYou can click links on the website by referencing the text inside of the link/button, by answering in the following JSON format:\n{\"click\": \"Text in link\"}\nOnce you are on a URL and you have found the answer to the user's question, you can answer with a regular message.\nIn the beginning, go to a direct URL that you think might contain the answer"
        },
        {
            "comment": "The code is a part of an interactive assistant program that uses the Google search engine to find information based on user queries. It keeps track of the conversation in the 'messages' array and can also take screenshots of webpages if needed. The current user query or URL is being stored in the variable 'url'.",
            "location": "\"/media/root/Toshiba XG3/works/gpt4v-browsing/docs/src/vision_crawl.js\":161-199",
            "content": " to the user's question. Prefer to go directly to sub-urls like 'https://google.com/search?q=search' if applicable. Prefer to use Google for simple queries. If the user provides a direct URL, go to that one.`,\n        }\n    ];\n    console.log(\"GPT: How can I assist you today?\")\n    const prompt = await input(\"You: \");\n    console.log();\n    messages.push({\n        \"role\": \"user\",\n        \"content\": prompt,\n    });\n    let url;\n    let screenshot_taken = false;\n    while( true ) {\n        if( url ) {\n            console.log(\"Crawling \" + url);\n            await page.goto( url, {\n                waitUntil: \"domcontentloaded\",\n            } );\n            await highlight_links( page );\n            await Promise.race( [\n                waitForEvent(page, 'load'),\n                sleep(timeout)\n            ] );\n            await highlight_links( page );\n            await page.screenshot( {\n                path: \"screenshot.jpg\",\n                quality: 100,\n            } );\n            screenshot_taken = true;\n            url = null;"
        },
        {
            "comment": "If a screenshot was taken, add it to the messages array with accompanying text, then reset the screenshot_taken flag. Send the updated messages array in an openai.chat.completions.create API call to get a response from GPT-4 Vision Preview model.",
            "location": "\"/media/root/Toshiba XG3/works/gpt4v-browsing/docs/src/vision_crawl.js\":200-229",
            "content": "        }\n        if( screenshot_taken ) {\n            const base64_image = await image_to_base64(\"screenshot.jpg\");\n            messages.push({\n                \"role\": \"user\",\n                \"content\": [\n                    {\n                        \"type\": \"image_url\",\n                        \"image_url\": base64_image,\n                    },\n                    {\n                        \"type\": \"text\",\n                        \"text\": \"Here's the screenshot of the website you are on right now. You can click on links with {\\\"click\\\": \\\"Link text\\\"} or you can crawl to another URL if this one is incorrect. If you find the answer to the user's question, you can respond normally.\",\n                    }\n                ]\n            });\n            screenshot_taken = false;\n        }\n        const response = await openai.chat.completions.create({\n            model: \"gpt-4-vision-preview\",\n            max_tokens: 1024,\n            //seed: 665234,\n            messages: messages,\n        });\n        const message = response.choices[0].message;"
        },
        {
            "comment": "Extracts link text from the message, finds matching elements on the page, and clicks on them.",
            "location": "\"/media/root/Toshiba XG3/works/gpt4v-browsing/docs/src/vision_crawl.js\":230-262",
            "content": "        const message_text = message.content;\n        messages.push({\n            \"role\": \"assistant\",\n            \"content\": message_text,\n        });\n        console.log( \"GPT: \" + message_text );\n        if( message_text.indexOf('{\"click\": \"') !== -1 ) {\n            let parts = message_text.split('{\"click\": \"');\n            parts = parts[1].split('\"}');\n            const link_text = parts[0].replace(/[^a-zA-Z0-9 ]/g, '');\n            console.log(\"Clicking on \" + link_text)\n            try {\n                const elements = await page.$$('[gpt-link-text]');\n                let partial;\n                let exact;\n                for( const element of elements ) {\n                    const attributeValue = await element.getAttribute('gpt-link-text');\n                    if( attributeValue.includes( link_text ) ) {\n                        partial = element;\n                    }\n                    if( attributeValue === link_text ) {\n                        exact = element;\n                    }\n                }"
        },
        {
            "comment": "This code is checking if the exact or partial link should be clicked. If not found, it throws an error. It then waits for a page load event or sleeps for a specified timeout, highlights links on the page, takes a screenshot, and continues with the next message if no errors occur.",
            "location": "\"/media/root/Toshiba XG3/works/gpt4v-browsing/docs/src/vision_crawl.js\":264-296",
            "content": "                if( exact ) {\n                    await exact.click();\n                } else if( partial ) {\n                    await partial.click();\n                } else {\n                    throw new Error( \"Can't find link\" );\n                }\n                await Promise.race( [\n                    waitForEvent(page, 'load'),\n                    sleep(timeout)\n                ] );\n                await highlight_links( page );\n                await page.screenshot( {\n                    path: \"screenshot.jpg\",\n                    quality: 100,\n                } );\n                screenshot_taken = true;\n            } catch( error ) {\n                console.log( \"ERROR: Clicking failed\" );\n                messages.push({\n                    \"role\": \"user\",\n                    \"content\": \"ERROR: I was unable to click that element\",\n                });\n            }\n            continue;\n        } else if( message_text.indexOf('{\"url\": \"') !== -1 ) {\n            let parts = message_text.split('{\"url\": \"');"
        },
        {
            "comment": "This code is capturing user input and adding it to a messages array with role \"user\" and content as the user's input.",
            "location": "\"/media/root/Toshiba XG3/works/gpt4v-browsing/docs/src/vision_crawl.js\":297-311",
            "content": "            parts = parts[1].split('\"}');\n            url = parts[0];\n            continue;\n        }\n        const prompt = await input(\"You: \");\n        console.log();\n        messages.push({\n            \"role\": \"user\",\n            \"content\": prompt,\n        });\n    }\n})();"
        }
    ]
}